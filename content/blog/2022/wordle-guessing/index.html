---
title: Wordle Guessing
author: Garrick Aden-Buie
date: '2022-01-15'
slug: wordle-guessing
categories:
  - Blog
tags:
  - R
description: Optimizing wordle guesses. It's only fun if you can solve it with R.
#twitterImage: /path/to/image.png
source_link: 'https://github.com/gadenbuie/garrickadenbuie-com/blob/main/content/blog/2022/wordle-guessing/index.Rmd'
keywords: rstats
editor_options:
  chunk_output_type: console
---

<script src="{{< blogdown/postref >}}index_files/header-attrs-2.11/header-attrs.js"></script>


<!-- Links -->
<div id="setup" class="section level2">
<h2>Setup</h2>
<p><a href="https://www.powerlanguage.co.uk/wordle/">wordle</a> is…</p>
<pre class="r"><code># List of English words from Scrabble dictionary
install.packages(&quot;words&quot;)</code></pre>
<pre class="r"><code>library(dplyr)
library(purrr)
library(stringr)

words &lt;- 
  words::words %&gt;%
  as_tibble() %&gt;%
  filter(word_length == 5) %&gt;% 
  select(-word_length)

words</code></pre>
<pre><code>## # A tibble: 9,330 × 1
##    word 
##    &lt;chr&gt;
##  1 aahed
##  2 aalii
##  3 aargh
##  4 abaca
##  5 abaci
##  6 aback
##  7 abaft
##  8 abaka
##  9 abamp
## 10 abase
## # … with 9,320 more rows</code></pre>
<p>Letter frequency of appearance in a word</p>
<pre class="r"><code>letter_freq &lt;-
  words %&gt;%
  pull(word) %&gt;% 
  str_split(&quot;&quot;) %&gt;%
  map(unique) %&gt;%
  unlist() %&gt;%
  table() %&gt;%
  sort() %&gt;%
  rev() %&gt;%
  `/`(nrow(words)) %&gt;%
  c()

letter_freq</code></pre>
<pre><code>##           s           e           a           r           o           i 
## 0.459699893 0.443193998 0.405680600 0.305359057 0.296248660 0.282207931 
##           l           t           n           u           d           c 
## 0.246945338 0.237620579 0.214362272 0.187888532 0.178349411 0.158628081 
##           y           p           m           h           g           b 
## 0.155198285 0.147052519 0.142979636 0.133654877 0.118435155 0.114147910 
##           k           f           w           v           z           x 
## 0.105251876 0.077920686 0.076312969 0.052625938 0.026473741 0.023579850 
##           j           q 
## 0.021221865 0.009110397</code></pre>
<p>Letter frequency by position</p>
<pre class="r"><code>letter_freq_pos &lt;- 
  words %&gt;% 
  select(word) %&gt;% 
  mutate(letter = word) %&gt;% 
  tidyr::separate_rows(letter, sep = &quot;&quot;) %&gt;% 
  filter(letter != &quot;&quot;) %&gt;%
  group_by(word) %&gt;%
  mutate(position = row_number()) %&gt;%
  ungroup() %&gt;%
  select(-word) %&gt;%
  group_by(position, letter) %&gt;%
  summarize(n = n() / nrow(words), .groups = &quot;drop&quot;) %&gt;% 
  tidyr::pivot_wider(names_from = position, values_from = n, values_fill = 0, names_prefix = &quot;p&quot;)

letter_freq_pos</code></pre>
<pre><code>## # A tibble: 26 × 6
##    letter     p1       p2      p3      p4      p5
##    &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 a      0.0572 0.172    0.0952  0.0789  0.0453 
##  2 b      0.0693 0.00600  0.0256  0.0170  0.00439
##  3 c      0.0759 0.0139   0.0322  0.0340  0.0108 
##  4 d      0.0519 0.00686  0.0316  0.0354  0.0652 
##  5 e      0.0225 0.124    0.0646  0.194   0.105  
##  6 f      0.0479 0.00150  0.0141  0.0177  0.00622
##  7 g      0.0484 0.00600  0.0282  0.0323  0.0107 
##  8 h      0.0386 0.0437   0.00815 0.0168  0.0296 
##  9 i      0.0134 0.111    0.0839  0.0684  0.0193 
## 10 j      0.0155 0.000965 0.00322 0.00171 0      
## # … with 16 more rows</code></pre>
</div>
<div id="first-choice" class="section level2">
<h2>First Choice</h2>
<pre class="r"><code>score_entropy &lt;- function(word) {
  chars &lt;- str_split(word, &quot;&quot;)[[1]]
  p &lt;- letter_freq[chars]
  # we learn something but not much from duplicated letters
  p[duplicated(chars)] &lt;- min(letter_freq)
  - sum(p * log(p, base = 2))
}

words %&gt;% 
  mutate(score = map_dbl(word, score_entropy)) %&gt;% 
  arrange(desc(score))</code></pre>
<pre><code>## # A tibble: 9,330 × 2
##    word  score
##    &lt;chr&gt; &lt;dbl&gt;
##  1 arose  2.61
##  2 arise  2.60
##  3 raise  2.60
##  4 reais  2.60
##  5 serai  2.60
##  6 osier  2.59
##  7 arles  2.58
##  8 earls  2.58
##  9 lares  2.58
## 10 laser  2.58
## # … with 9,320 more rows</code></pre>
<pre class="r"><code>score_choice &lt;- function(word) {
  word_len &lt;- str_length(word)
  chars &lt;- str_split(word, &quot;&quot;)[[1]]
  chars &lt;- unique(chars)
  1 - prod(1 - letter_freq[chars])
}

words_first_choice &lt;- 
  words %&gt;% 
  mutate(score = map_dbl(word, score_entropy)) %&gt;% 
  arrange(desc(score))

words_first_choice</code></pre>
<pre><code>## # A tibble: 9,330 × 2
##    word  score
##    &lt;chr&gt; &lt;dbl&gt;
##  1 arose  2.61
##  2 arise  2.60
##  3 raise  2.60
##  4 reais  2.60
##  5 serai  2.60
##  6 osier  2.59
##  7 arles  2.58
##  8 earls  2.58
##  9 lares  2.58
## 10 laser  2.58
## # … with 9,320 more rows</code></pre>
<p>According to this, the best first-choice words are
arose, arise, and raise.
<strong>arose</strong> uses all five of the letters that most commonly appear in a word.</p>
</div>
<div id="second-choice" class="section level2">
<h2>Second Choice</h2>
<p>After your first choice, you know up to three pieces of additional information.
Some of the letters in your guess</p>
<ol style="list-style-type: decimal">
<li>⬛ aren’t in the solution</li>
<li>🟨 are in the solution but not where you guessed</li>
<li>🟩 are in the solution and are where you guessed</li>
</ol>
<p>What if you guessed <strong>arose</strong> and got five gray boxes telling you that none of those letters appear in the solution?</p>
<pre class="r"><code>str_has_none_of &lt;- function(words, letters) {
  words &lt;- str_split(words, &quot;&quot;)
  map_lgl(words, ~ length(intersect(letters, .x)) == 0)
}

words_first_choice %&gt;% 
  filter(str_has_none_of(word, c(&quot;a&quot;, &quot;r&quot;, &quot;o&quot;, &quot;s&quot;, &quot;e&quot;)))</code></pre>
<pre><code>## # A tibble: 449 × 2
##    word  score
##    &lt;chr&gt; &lt;dbl&gt;
##  1 unlit  2.44
##  2 until  2.44
##  3 linty  2.40
##  4 culti  2.38
##  5 tulip  2.37
##  6 uplit  2.37
##  7 cunit  2.36
##  8 cutin  2.36
##  9 tunic  2.36
## 10 unity  2.35
## # … with 439 more rows</code></pre>
<p>If none of the letters in <strong>arose</strong> and <strong>until</strong> appear in the solution, then your answer is most definitely…</p>
<pre class="r"><code>letters_guess &lt;- str_split(&quot;arose until&quot;, &quot;&quot;)[[1]]

words_first_choice %&gt;% 
  filter(str_has_none_of(word, letters_guess))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   word  score
##   &lt;chr&gt; &lt;dbl&gt;
## 1 pygmy  1.65</code></pre>
<p>If you learn something from the guess, though, you can filter the word list based on the information you just learned.</p>
<!-- arose, intro, motor -->
<div class="wordle">
<span class="letter letter-large incorrect">
a
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large in-solution">
r
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large in-solution">
o
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large incorrect">
s
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large incorrect">
e
<span class="sr-only">(incorrect)</span>
</span>
</div>
<p>Say we guess <strong>arose</strong> and wordle reveals that <span class="letter">R</span> and <span class="letter">O</span> appear in the solution.
We now know that the solution:</p>
<ol style="list-style-type: decimal">
<li>Doesn’t have <span class="letter">A</span>, <span class="letter">S</span> or <span class="letter">E</span></li>
<li>Does contain <span class="letter">R</span> and <span class="letter">O</span></li>
<li>Doesn’t have <span class="letter">R</span> as the 2<sup>nd</sup> letter and <span class="letter">O</span> as the 3<sup>rd</sup>.</li>
</ol>
<p>We’ve already implemented step 1 as <code>str_has_none_of()</code>.
We also need a similar version called <code>str_has_all_of()</code>.</p>
<pre class="r"><code>str_has_all_of &lt;- function(words, letters) {
  words &lt;- str_split(words, &quot;&quot;)
  map_lgl(words, ~ length(setdiff(letters, .x)) == 0)
}

str_has_all_of(&quot;rhino&quot;, c(&quot;r&quot;, &quot;o&quot;))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>And finally we can write the third piece of information as a regular expression: <code>".[^r][^o].."</code>.
The <code>[]</code> indicate a set of options that could be present at a location in the string.
The opening <code>^</code> negates the selection, so <code>[^r]</code> means <em>a character that isn’t</em> <code>r</code>.</p>
<pre class="r"><code>words_first_choice %&gt;% 
  filter(
    str_has_none_of(word, c(&quot;a&quot;, &quot;s&quot;, &quot;e&quot;)),
    str_has_all_of(word, c(&quot;r&quot;, &quot;o&quot;)),
    str_detect(word, &quot;.[^r][^o]..&quot;)
  )</code></pre>
<pre><code>## # A tibble: 108 × 2
##    word  score
##    &lt;chr&gt; &lt;dbl&gt;
##  1 lirot  2.55
##  2 intro  2.53
##  3 nitro  2.53
##  4 roily  2.47
##  5 toric  2.47
##  6 porin  2.44
##  7 minor  2.44
##  8 curio  2.43
##  9 rhino  2.42
## 10 round  2.42
## # … with 98 more rows</code></pre>
<p><strong>lirot</strong> is an unusual word, so let’s choose the next word on the list: <strong>intro</strong>.</p>
<div class="wordle">
<span class="letter letter-large incorrect">
a
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large in-solution">
r
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large in-solution">
o
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large incorrect">
s
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large incorrect">
e
<span class="sr-only">(incorrect)</span>
</span>
</div>
<div class="wordle">
<span class="letter letter-large incorrect">
i
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large incorrect">
n
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large correct">
t
<span class="sr-only">(correct)</span>
</span>
<span class="letter letter-large in-solution">
r
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large in-solution">
o
<span class="sr-only">(in solution, wrong position)</span>
</span>
</div>
<p>wordle thinks and tells us that we have <span class="letter">T</span> in the right spot!
Also, we now know that <span class="letter">I</span> and <span class="letter">N</span> aren’t in the solution,
and we still haven’t got <span class="letter">R</span> and <span class="letter">O</span> in the right place.</p>
<p>We can repeat the step above, but using a new regular expression: <code>".[^r]t[^r][^o]"</code>.
Notice that we know a little more about where <span class="letter">R</span> and <span class="letter">O</span> <em>can’t be</em>,
but importantly we have <code>t</code> as the middle character.</p>
<p>This leaves us with a few good choices:</p>
<pre class="r"><code>words_first_choice %&gt;% 
  filter(
    str_has_none_of(word, c(&quot;a&quot;, &quot;s&quot;, &quot;e&quot;, &quot;i&quot;, &quot;n&quot;)),
    str_has_all_of(word, c(&quot;r&quot;, &quot;o&quot;, &quot;t&quot;)),
    str_detect(word, &quot;.[^r]t[^r][^o]&quot;)
  )</code></pre>
<pre><code>## # A tibble: 4 × 2
##   word  score
##   &lt;chr&gt; &lt;dbl&gt;
## 1 rotch  2.34
## 2 tutor  2.05
## 3 motor  2.00
## 4 rotor  1.66</code></pre>
<p><strong>rotch</strong> seems very unlikely, so we can pick from <strong>tutor</strong>, <strong>motor</strong> and <strong>rotor</strong>.
But notice that the these include a small set of the same letters.
In a sense, we might ask ourselves a new question — which is the more likely starting combination:
<strong>tu</strong>, <strong>mo</strong> or <strong>ro</strong>?</p>
<p>At this point, you could just guess.
It is a game after all!
But no, let’s power forward and add more complexity to this blog post.</p>
<p>What if we switched our scoring at this point and considered the position of the letters in the candidate words?
Doing something medium-naive, let’s frame this as:
what’s the probability of <span class="letter">T</span> in the first position <strong>and</strong>
<span class="letter">U</span> in the second <strong>and</strong> so on…</p>
<pre class="r"><code>score_by_position &lt;- function(word) {
  chars &lt;- str_split(word, &quot;&quot;)[[1]]
  
  res &lt;- c()
  for (i in seq_along(chars)) {
    pos_alpha &lt;- which(letters == chars[i])
    p &lt;- letter_freq_pos[[str_c(&quot;p&quot;, i)]][pos_alpha]
    res &lt;- c(res, p)
  }
  
  prod(res)
}

words_score_pos &lt;- 
  words %&gt;% 
  mutate(score_pos = map_dbl(word, score_by_position)) %&gt;%
  arrange(desc(score_pos))

words_score_pos</code></pre>
<pre><code>## # A tibble: 9,330 × 2
##    word  score_pos
##    &lt;chr&gt;     &lt;dbl&gt;
##  1 sores 0.000102 
##  2 sanes 0.0000917
##  3 sales 0.0000845
##  4 sones 0.0000831
##  5 seres 0.0000813
##  6 soles 0.0000766
##  7 sires 0.0000727
##  8 cares 0.0000719
##  9 senes 0.0000660
## 10 bares 0.0000657
## # … with 9,320 more rows</code></pre>
<p>If we join this with our “new information” score, we now have to scores to choose from:</p>
<pre class="r"><code>words_first_choice %&gt;% 
  filter(
    str_has_none_of(word, c(&quot;a&quot;, &quot;s&quot;, &quot;e&quot;, &quot;i&quot;, &quot;n&quot;)),
    str_has_all_of(word, c(&quot;r&quot;, &quot;o&quot;, &quot;t&quot;)),
    str_detect(word, &quot;.[^r]t[^r][^o]&quot;)
  ) %&gt;% 
  left_join(words_score_pos) %&gt;% 
  arrange(desc(score_pos))</code></pre>
<pre><code>## # A tibble: 4 × 3
##   word  score   score_pos
##   &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;
## 1 motor  2.00 0.00000129 
## 2 rotor  1.66 0.00000121 
## 3 tutor  2.05 0.000000960
## 4 rotch  2.34 0.000000377</code></pre>
<p>Now we see that <strong>motor</strong> and <strong>rotor</strong> are the most likely words based on their position.
We guess <strong>motor</strong>… and we’re right!</p>
<div class="wordle">
<span class="letter letter-large incorrect">
a
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large in-solution">
r
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large in-solution">
o
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large incorrect">
s
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large incorrect">
e
<span class="sr-only">(incorrect)</span>
</span>
</div>
<div class="wordle">
<span class="letter letter-large incorrect">
i
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large incorrect">
n
<span class="sr-only">(incorrect)</span>
</span>
<span class="letter letter-large correct">
t
<span class="sr-only">(correct)</span>
</span>
<span class="letter letter-large in-solution">
r
<span class="sr-only">(in solution, wrong position)</span>
</span>
<span class="letter letter-large in-solution">
o
<span class="sr-only">(in solution, wrong position)</span>
</span>
</div>
<div class="wordle">
<span class="letter letter-large correct">
m
<span class="sr-only">(correct)</span>
</span>
<span class="letter letter-large correct">
o
<span class="sr-only">(correct)</span>
</span>
<span class="letter letter-large correct">
t
<span class="sr-only">(correct)</span>
</span>
<span class="letter letter-large correct">
o
<span class="sr-only">(correct)</span>
</span>
<span class="letter letter-large correct">
r
<span class="sr-only">(correct)</span>
</span>
</div>
<p>It only took three guesses!
It’s almost like I planned this example to work out just like I wanted.</p>
</div>
<div id="generalizing" class="section level2">
<h2>Generalizing</h2>
<p>Okay, let’s do this for any number of guesses.
First, let’s join our scored words into a single data frame.</p>
<pre class="r"><code>words_scored &lt;- left_join(
  words_first_choice,
  words_score_pos,
  by = &quot;word&quot;
)</code></pre>
<p>Then, we need a function that takes our guesses and results and generalizes them into the pieces of information our guesses reveal about the solution.
Behold, <code>summarize_guesses()</code>:</p>
<pre class="r"><code>#&#39; @param guesses A vector of words that you have guessed
#&#39; @param result A vector of results for each guess using `.` for a miss, `-` 
#&#39;   for a letter in the solution that isn&#39;t in the right place and `+` for a
#&#39;   letter that&#39;s in the right spot.
summarize_guesses &lt;- function(guesses, results) {
  stopifnot(all(str_length(c(guesses, results)) == 5))
  
  guesses &lt;- str_split(guesses, &quot;&quot;)
  results &lt;- str_split(results, &quot;&quot;)
  
  exclude &lt;- character(5)
  exact &lt;- character(5)
  bucket_keep &lt;- c()
  bucket_discard &lt;- c()
  
  walk2(guesses, results, function(g, r) {
    if (any(r == &quot;+&quot;)) {
      exact[r == &quot;+&quot;] &lt;&lt;- g[r == &quot;+&quot;]
      bucket_keep &lt;&lt;- c(bucket_keep, g[r == &quot;+&quot;])
    }
    if (any(r == &quot;-&quot;)) {
      bucket_keep &lt;&lt;- c(bucket_keep, g[r == &quot;-&quot;])
      exclude[r == &quot;-&quot;] &lt;&lt;- paste0(exclude[r == &quot;-&quot;], g[r == &quot;-&quot;])
    }
    if (any(r == &quot;.&quot;)) {
      bucket_discard &lt;&lt;- c(bucket_discard, g[r == &quot;.&quot;])
    }
  })
  
  exclude[exclude != &quot;&quot;] &lt;- paste0(&quot;[^&quot;, exclude[exclude != &quot;&quot;], &quot;]&quot;)
  exact[exact == &quot;&quot;] &lt;- NA_character_
  exclude[exclude == &quot;&quot;] &lt;- NA_character_
  
  pattern &lt;- coalesce(coalesce(exact, exclude), &quot;.&quot;)
  
  # Say you guess a word with two Ts, 
  # but there&#39;s only one T in the solution.
  # T will appear on keep and discard bucket,
  # so we need to explicitly keep it.
  # (we could use that info, though, e.g. at most 1 T)
  bucket_discard &lt;- setdiff(bucket_discard, bucket_keep)
  
  list(
    discard = unique(bucket_discard),
    keep = unique(bucket_keep),
    specific = str_c(pattern, collapse = &quot;&quot;)
  )
}</code></pre>
<pre class="r"><code>summarize_guesses(&quot;arose&quot;, &quot;.--..&quot;)</code></pre>
<pre><code>## $discard
## [1] &quot;a&quot; &quot;s&quot; &quot;e&quot;
## 
## $keep
## [1] &quot;r&quot; &quot;o&quot;
## 
## $specific
## [1] &quot;.[^r][^o]..&quot;</code></pre>
<pre class="r"><code>guess_results &lt;- summarize_guesses(c(&quot;arose&quot;, &quot;intro&quot;), c(&quot;.--..&quot;, &quot;..+--&quot;))

words_first_choice %&gt;% 
  left_join(words_score_pos) %&gt;%
  filter(
    str_has_none_of(word, guess_results$discard),
    str_has_all_of(word, guess_results$keep),
    str_detect(word, guess_results$specific)
  )</code></pre>
<pre><code>## # A tibble: 4 × 3
##   word  score   score_pos
##   &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;
## 1 rotch  2.34 0.000000377
## 2 tutor  2.05 0.000000960
## 3 motor  2.00 0.00000129 
## 4 rotor  1.66 0.00000121</code></pre>
</div>
<div id="all-together-now" class="section level2">
<h2>All together now</h2>
<pre class="r"><code>score_next_guess &lt;- function(guesses, results) {
  guess_results &lt;- summarize_guesses(guesses, results)
  
  words_scored %&gt;%
    filter(
      str_has_none_of(word, guess_results$discard),
      str_has_all_of(word, guess_results$keep),
      str_detect(word, guess_results$specific)
    )
}</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;intro&quot;), 
  results = c(&quot;.--..&quot;, &quot;..+--&quot;)
)</code></pre>
<pre><code>## # A tibble: 4 × 3
##   word  score   score_pos
##   &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;
## 1 rotch  2.34 0.000000377
## 2 tutor  2.05 0.000000960
## 3 motor  2.00 0.00000129 
## 4 rotor  1.66 0.00000121</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;intro&quot;, &quot;rotch&quot;), 
  results = c(&quot;.--..&quot;, &quot;..+--&quot;, &quot;-++..&quot;)
)</code></pre>
<pre><code>## # A tibble: 1 × 3
##   word  score  score_pos
##   &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;
## 1 motor  2.00 0.00000129</code></pre>
<p>How did this work for me today?</p>
<pre class="r"><code># 2022-01-16
score_next_guess(
  guesses = c(&quot;arose&quot;),
  results = c(&quot;----.&quot;)
)</code></pre>
<pre><code>## # A tibble: 28 × 3
##    word  score    score_pos
##    &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt;
##  1 solar  2.58 0.00000591  
##  2 ratos  2.58 0.00000702  
##  3 rotas  2.58 0.00000921  
##  4 taros  2.58 0.0000172   
##  5 toras  2.58 0.0000226   
##  6 roans  2.56 0.0000134   
##  7 sonar  2.56 0.00000641  
##  8 roads  2.53 0.00000793  
##  9 sarod  2.53 0.00000666  
## 10 oscar  2.51 0.0000000235
## # … with 18 more rows</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;solar&quot;),
  results = c(&quot;----.&quot;, &quot;+++++&quot;)
)</code></pre>
<pre><code>## # A tibble: 1 × 3
##   word  score  score_pos
##   &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;
## 1 solar  2.58 0.00000591</code></pre>
<p>How can we get to igloo?</p>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;),
  results = c(&quot;..-..&quot;)
)</code></pre>
<pre><code>## # A tibble: 336 × 3
##    word  score    score_pos
##    &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt;
##  1 indol  2.45 0.0000000247
##  2 tondi  2.45 0.000000510 
##  3 lotic  2.45 0.000000264 
##  4 pilot  2.43 0.00000148  
##  5 colin  2.43 0.00000233  
##  6 nicol  2.43 0.000000177 
##  7 noily  2.43 0.00000194  
##  8 ontic  2.43 0.0000000210
##  9 tonic  2.43 0.000000553 
## 10 litho  2.41 0.000000116 
## # … with 326 more rows</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;indol&quot;),
  results = c(&quot;..-..&quot;, &quot;+..+-&quot;)
)</code></pre>
<pre><code>## # A tibble: 1 × 3
##   word  score     score_pos
##   &lt;chr&gt; &lt;dbl&gt;         &lt;dbl&gt;
## 1 igloo  1.96 0.00000000817</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;indol&quot;, &quot;igloo&quot;),
  results = c(&quot;..-..&quot;, &quot;+..+-&quot;, &quot;+++++&quot;)
)</code></pre>
<pre><code>## # A tibble: 1 × 3
##   word  score     score_pos
##   &lt;chr&gt; &lt;dbl&gt;         &lt;dbl&gt;
## 1 igloo  1.96 0.00000000817</code></pre>
<p>Ferry furor?</p>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;),
  results = c(&quot;.-..-&quot;)
)</code></pre>
<pre><code>## # A tibble: 300 × 3
##    word  score    score_pos
##    &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt;
##  1 liter  2.55 0.00000289  
##  2 relit  2.55 0.00000153  
##  3 tiler  2.55 0.00000558  
##  4 liner  2.53 0.00000432  
##  5 inert  2.53 0.0000000679
##  6 inter  2.53 0.000000209 
##  7 niter  2.53 0.00000148  
##  8 uteri  2.50 0.0000000172
##  9 idler  2.50 0.0000000716
## 10 riled  2.50 0.00000465  
## # … with 290 more rows</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;liter&quot;),
  results = c(&quot;.-..-&quot;, &quot;...--&quot;)
) %&gt;% 
  arrange(desc(score_pos))</code></pre>
<pre><code>## # A tibble: 44 × 3
##    word  score  score_pos
##    &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;
##  1 berry  1.88 0.00000434
##  2 perry  1.93 0.00000413
##  3 ferny  2.22 0.00000344
##  4 derry  1.97 0.00000325
##  5 merry  1.92 0.00000325
##  6 beery  1.88 0.00000307
##  7 perky  2.21 0.00000301
##  8 ferry  1.81 0.00000300
##  9 peery  1.93 0.00000292
## 10 perdy  2.31 0.00000280
## # … with 34 more rows</code></pre>
<pre class="r"><code># skip berry and perry
score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;liter&quot;, &quot;ferny&quot;),
  results = c(&quot;.-..-&quot;, &quot;...--&quot;, &quot;+++.+&quot;)
)</code></pre>
<pre><code>## # A tibble: 1 × 3
##   word  score  score_pos
##   &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;
## 1 ferry  1.81 0.00000300</code></pre>
<pre class="r"><code>score_next_guess(
  guesses = c(&quot;arose&quot;, &quot;liter&quot;, &quot;ferny&quot;, &quot;ferry&quot;),
  results = c(&quot;.-..-&quot;, &quot;...--&quot;, &quot;+++.+&quot;, &quot;+++++&quot;)
)</code></pre>
<pre><code>## # A tibble: 1 × 3
##   word  score  score_pos
##   &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;
## 1 ferry  1.81 0.00000300</code></pre>
<style type="text/css">
.wordle {
  margin-left: auto;
  margin-right: auto;
  width: max-content;
  min-width: 8em;
}
.letter {
  display: inline-flex;
  height: 1em;
  width: 1em;
  border: 2px rgba(125, 125, 125, 0.25) solid;
  justify-content: center;
  align-items: center;
  margin-top: 0.2em;
  text-transform: uppercase;
}
.letter-large {
  font-size: 2em;
  height: 1.5em;
  width: 1.5em;
}
.letter.incorrect {
  color: var(--slate-20);
  background-color: var(--slate-80);
}
.letter.correct {
  color: var(--green-20);
  background-color: var(--green-80);
}
.letter.in-solution {
  color: var(--orange-20);
  background-color: var(--orange-80);
}
@media (prefers-color-scheme: dark) {
  .letter.incorrect {
    color: var(--slate-80);
    background-color: var(--slate-30);
  }
  .letter.correct {
    color: var(--green-80);
    background-color: var(--green-30);
  }
  .letter.in-solution {
    color: var(--orange-80);
    background-color: var(--orange-30);
  }
}
</style>
</div>
