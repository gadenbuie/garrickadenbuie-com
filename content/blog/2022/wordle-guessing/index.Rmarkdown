---
title: Wordle Guessing
author: Garrick Aden-Buie
date: '2022-01-15'
slug: wordle-guessing
categories:
  - Blog
tags:
  - R
description: Optimizing wordle guesses. It's only fun if you can solve it with R.
#twitterImage: /path/to/image.png
source_link: 'https://github.com/gadenbuie/garrickadenbuie-com/blob/main/content/blog/2022/wordle-guessing/index.Rmd'
keywords: rstats
editor_options:
  chunk_output_type: console
---

<!-- Links -->
[wordle]: https://www.powerlanguage.co.uk/wordle/

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, warning = FALSE, message = FALSE,
  fig.width = 9, fig.height = 10
)
options(htmltools.dir.version = TRUE)
```

```{r wordle-component, echo=FALSE, cahe = FALSE}
wordle_component <- function(word, answer, large = TRUE) {
  word <- stringr::str_split(word, "")[[1]]
  answer <- stringr::str_split(answer, "")[[1]]
  letters <- purrr::map2(word, answer, function(letter, ans) {
    if (ans == ".") {
      htmltools::span(
        class = c("letter", if (large) "letter-large", "absent"),
        letter,
        htmltools::span(class = "sr-only", "(absent)")
      )
    } else if (ans == "-") {
      htmltools::span(
        class = c("letter", if (large) "letter-large", "present"),
        letter,
        htmltools::span(class = "sr-only", "(in solution, wrong position)")
      )
    } else {
      htmltools::span(
        class = c("letter", if (large) "letter-large", "correct"),
        letter,
        htmltools::span(class = "sr-only", "(correct)")
      )
    }
  })
  htmltools::div(class = "wordle-solo", letters)
}
```

::: {.intro .center .mw6-l .mb3}
Have you heard of [Wordle]?
Who am I kidding, of course you've heard of Wordle!
In fact, I'm pretty certain we're way past peak Wordle at this point.

Here's a Wordle helper that doesn't completely take the fun out of the guessing, while also making sure you've got a good chance at winning every time.

Type your guesses below and then use the buttons to report Wordle's response. As soon as you add the results for a new word, the table of next guess candidates will update! Pick wisely.
:::

```{=html}
<div id="wordle" style="position:relative"><textarea style="height:0;width:0;position:absolute;left:-100vw;bottom:0"></textarea></div>
<div id="words-stats"></div>
<div id="words-table"></div>
```

## Setup

```{r load-words}
library(dplyr)
library(purrr)
library(stringr)

wordle_words <- jsonlite::fromJSON("wordle.json", simplifyVector = TRUE)

words <- wordle_words %>% unlist() %>% unique()
```

Letter frequency of appearance in a word

```{r letter-freq}
letter_freq <-
  words %>%
  # pull(word) %>% 
  str_split("") %>%
  map(unique) %>%
  unlist() %>%
  table() %>%
  sort() %>%
  rev() %>%
  `/`(length(words)) %>%
  c()

letter_freq
```

Letter frequency by position

```{r letter-freq-pos}
letter_freq_pos <- 
  tibble(word = words) %>% 
  select(word) %>% 
  mutate(letter = word) %>% 
  tidyr::separate_rows(letter, sep = "") %>% 
  filter(letter != "") %>%
  group_by(word) %>%
  mutate(position = row_number()) %>%
  ungroup() %>%
  select(-word) %>%
  group_by(position, letter) %>%
  summarize(n = n() / length(words), .groups = "drop") %>% 
  tidyr::pivot_wider(names_from = position, values_from = n, values_fill = 0, names_prefix = "p")

letter_freq_pos
```

## First Choice

```{r entropy}
score_entropy <- function(word) {
  chars <- str_split(word, "")[[1]]
  p <- letter_freq[chars]
  # we learn something but not much from duplicated letters
  p[duplicated(chars)] <- min(letter_freq)
  - sum(p * log(p, base = 2))
}

tibble(word = words) %>% 
  mutate(score = map_dbl(word, score_entropy)) %>% 
  arrange(desc(score))
```

```{r words_first_choice}
words_first_choice <- 
  tibble(word = words) %>% 
  mutate(score = map_dbl(word, score_entropy)) %>% 
  arrange(desc(score))

words_first_choice
```

According to this, the best first-choice words are
`r knitr::combine_words(words_first_choice$word[1:3])`.
**arose** uses all five of the letters that most commonly appear in a word.

## Second Choice

After your first choice, you know up to three pieces of additional information.
Some of the letters in your guess

1. &#x2B1B; aren't in the solution
2. &#x1F7E8; are in the solution but not where you guessed
3. &#x1F7E9; are in the solution and are where you guessed

What if you guessed **arose** and got five gray boxes telling you that none of those letters appear in the solution?

```{r str_has_none_of}
str_has_none_of <- function(words, letters) {
  words <- str_split(words, "")
  map_lgl(words, ~ length(intersect(letters, .x)) == 0)
}

words_first_choice %>% 
  filter(str_has_none_of(word, c("a", "r", "o", "s", "e")))
```

If none of the letters in **arose** and **until** appear in the solution, then your answer is most definitely...

```{r third-strike}
letters_guess <- str_split("arose until", "")[[1]]

words_first_choice %>% 
  filter(str_has_none_of(word, letters_guess))
```

If you learn something from the guess, though, you can filter the word list based on the information you just learned.

<!-- arose, intro, motor -->

`r wordle_component("arose", ".--..")`

Say we guess **arose** and wordle reveals that [R]{.letter} and [O]{.letter} appear in the solution.
We now know that the solution:

1. Doesn't have [A]{.letter}, [S]{.letter} or [E]{.letter}
1. Does contain [R]{.letter} and [O]{.letter}
1. Doesn't have [R]{.letter} as the 2^nd^ letter and [O]{.letter} as the 3^rd^.

We've already implemented step 1 as `str_has_none_of()`.
We also need a similar version called `str_has_all_of()`.

```{r str-has-all-of}
str_has_all_of <- function(words, letters) {
  words <- str_split(words, "")
  map_lgl(words, ~ length(setdiff(letters, .x)) == 0)
}

str_has_all_of("rhino", c("r", "o"))
```

And finally we can write the third piece of information as a regular expression: `".[^r][^o].."`.
The `[]` indicate a set of options that could be present at a location in the string.
The opening `^` negates the selection, so `[^r]` means _a character that isn't_ `r`.

```{r}
words_first_choice %>% 
  filter(
    str_has_none_of(word, c("a", "s", "e")),
    str_has_all_of(word, c("r", "o")),
    str_detect(word, ".[^r][^o]..")
  )
```

**lirot** is an unusual word, so let's choose the next word on the list: **intro**.

`r wordle_component("arose", ".--..")`
`r wordle_component("intro", "..+--")`

wordle thinks and tells us that we have [T]{.letter} in the right spot!
Also, we now know that [I]{.letter} and [N]{.letter} aren't in the solution,
and we still haven't got [R]{.letter} and [O]{.letter} in the right place.

We can repeat the step above, but using a new regular expression: `".[^r]t[^r][^o]"`.
Notice that we know a little more about where [R]{.letter} and [O]{.letter} _can't be_,
but importantly we have `t` as the middle character.

This leaves us with a few good choices:

```{r}
words_first_choice %>% 
  filter(
    str_has_none_of(word, c("a", "s", "e", "i", "n")),
    str_has_all_of(word, c("r", "o", "t")),
    str_detect(word, ".[^r]t[^r][^o]")
  )
```

**rotch** seems very unlikely, so we can pick from **tutor**, **motor** and **rotor**.
But notice that the these include a small set of the same letters.
In a sense, we might ask ourselves a new question â€” which is the more likely starting combination:
**tu**, **mo** or **ro**?

At this point, you could just guess.
It is a game after all!
But no, let's power forward and add more complexity to this blog post.

What if we switched our scoring at this point and considered the position of the letters in the candidate words?
Doing something medium-naive, let's frame this as:
what's the probability of [T]{.letter} in the first position **and**
[U]{.letter} in the second **and** so on...

```{r}
score_by_position <- function(word) {
  chars <- str_split(word, "")[[1]]
  
  res <- c()
  for (i in seq_along(chars)) {
    pos_alpha <- which(letters == chars[i])
    p <- letter_freq_pos[[str_c("p", i)]][pos_alpha]
    res <- c(res, p)
  }
  
  prod(res)
}

words_score_pos <- 
  tibble(word = words) %>% 
  mutate(
    score_pos = map_dbl(word, score_by_position),
    score_pos = score_pos / diff(range(score_pos))
  ) %>%
  arrange(desc(score_pos))

words_score_pos
```

If we join this with our "new information" score, we now have to scores to choose from:

```{r}
words_first_choice %>%
  filter(
    str_has_none_of(word, c("a", "s", "e", "i", "n")),
    str_has_all_of(word, c("r", "o", "t")),
    str_detect(word, ".[^r]t[^r][^o]")
  ) %>% 
  left_join(words_score_pos) %>% 
  arrange(desc(score_pos))
```

Now we see that **motor** and **rotor** are the most likely words based on their position.
We guess **motor**... and we're right!

`r wordle_component("arose", ".--..")`
`r wordle_component("intro", "..+--")`
`r wordle_component("motor", "+++++")`

It only took three guesses!
It's almost like I planned this example to work out just like I wanted.

## Generalizing

Okay, let's do this for any number of guesses.
First, let's join our scored words into a single data frame.

```{r words_scored}
words_scored <- left_join(
  words_first_choice,
  words_score_pos,
  by = "word"
)
```

Then, we need a function that takes our guesses and results and generalizes them into the pieces of information our guesses reveal about the solution.
Behold, `summarize_guesses()`:

```{r regex-after-guess}
#' @param guesses A vector of words that you have guessed
#' @param result A vector of results for each guess using `.` for a miss, `-` 
#'   for a letter in the solution that isn't in the right place and `+` for a
#'   letter that's in the right spot.
summarize_guesses <- function(guesses, results) {
  stopifnot(all(str_length(c(guesses, results)) == 5))
  
  guesses <- str_split(guesses, "")
  results <- str_split(results, "")
  
  exclude <- character(5)
  exact <- character(5)
  bucket_keep <- c()
  bucket_discard <- c()
  
  for (i in seq_along(guesses)) {
    g <- guesses[[i]]
    r <- results[[i]]
    
    if (any(r == "+")) {
      exact[r == "+"] <- g[r == "+"]
      bucket_keep <<- c(bucket_keep, g[r == "+"])
    }
    if (any(r == "-")) {
      bucket_keep <- c(bucket_keep, g[r == "-"])
      exclude[r == "-"] <- paste0(exclude[r == "-"], g[r == "-"])
    }
    if (any(r == ".")) {
      bucket_discard <- c(bucket_discard, g[r == "."])
    }
  }
  
  exclude[exclude != ""] <- paste0("[^", exclude[exclude != ""], "]")
  exact[exact == ""] <- NA_character_
  exclude[exclude == ""] <- NA_character_
  
  pattern <- coalesce(coalesce(exact, exclude), ".")
  
  # Say you guess a word with two Ts, 
  # but there's only one T in the solution.
  # T will appear on keep and discard bucket,
  # so we need to explicitly keep it.
  # (we could use that info, though, e.g. at most 1 T)
  bucket_discard <- setdiff(bucket_discard, bucket_keep)
  
  list(
    discard = unique(bucket_discard),
    keep = unique(bucket_keep),
    specific = str_c(pattern, collapse = "")
  )
}
```


```{r regex-after-guess-ex}
summarize_guesses("arose", ".--..")
```

```{r score-after-guess, eval=TRUE}
guess_results <- summarize_guesses(c("arose", "intro"), c(".--..", "..+--"))

words_first_choice %>% 
  left_join(words_score_pos) %>%
  filter(
    str_has_none_of(word, guess_results$discard),
    str_has_all_of(word, guess_results$keep),
    str_detect(word, guess_results$specific)
  )
```

## All together now

```{r score_next_guess}
score_next_guess <- function(guesses, results) {
  guess_results <- summarize_guesses(guesses, results)
  
  words_scored %>%
    filter(
      str_has_none_of(word, guess_results$discard),
      str_has_all_of(word, guess_results$keep),
      str_detect(word, guess_results$specific)
    )
}
```

```{r replay}
score_next_guess(
  guesses = c("arose", "intro"), 
  results = c(".--..", "..+--")
)

score_next_guess(
  guesses = c("arose", "intro", "rotch"), 
  results = c(".--..", "..+--", "-++..")
)
```

```{r replay-view, echo=FALSE}
map2(
  c("arose", "intro", "rotch", "motor"), 
  c(".--..", "..+--", "-++..", "+++++"),
  wordle_component
) %>% 
  htmltools::tagList()
```

How did this work for me today?

```{r live}
# 2022-01-16
score_next_guess(
  guesses = c("arose"),
  results = c("----.")
)
```

```{r live-view, echo=FALSE}
map2(
  c("arose", "solar"),
  c("----.", "+++++"),
  wordle_component
) %>% 
  htmltools::tagList()
```

How can we get to igloo?

```{r igloo}
score_next_guess(
  guesses = c("arose"),
  results = c("..-..")
)

score_next_guess(
  guesses = c("arose", "indol"),
  results = c("..-..", "+..+-")
)
```

```{r igloo-view, echo=FALSE}
map2(
  c("arose", "indol", "igloo"),
  c("..-..", "+..+-", "+++++"),
  wordle_component
) %>% 
  htmltools::tagList()
```

Ferry furor?

```{r ferry}
score_next_guess(
  guesses = c("arose"),
  results = c(".-..-")
)

score_next_guess(
  guesses = c("arose", "liter"),
  results = c(".-..-", "...--")
) %>% 
  arrange(desc(score_pos))

# skip berry and perry
score_next_guess(
  guesses = c("arose", "liter", "ferny"),
  results = c(".-..-", "...--", "+++.+")
)
```

```{r ferry-view, echo=FALSE}
map2(
  c("arose", "liter", "ferny", "ferry"),
  c(".-..-", "...--", "+++.+", "+++++"),
  wordle_component
) %>% 
  htmltools::tagList()
```

## Another thought

Embed the data into the webpage

```{r embed-words, echo=TRUE}
words_scored %>% 
  mutate(score_pos = score_pos / (max(score_pos) - min(score_pos))) %>% 
  jsonlite::write_json("wordle-scored.json")

htmltools::tags$script(
  id = "words-scored",
  type = "application/json",
  readLines("wordle-scored.json")
)
```

so that we can switch gears; the rest of the blog post is rendered _in your browser_.
This uses an extension I built for the js knitr engine for js4shiny.

```{r js4shiny, echo=TRUE}
js4shiny::html_setup_blogdown(stylize = "none")
```

And also, we'll use tidyjs in the browser. 
If you squint really hard, it's remarkably similar to the tidyverse, just with a JavaScript spin.

```{r tidy-js, echo=TRUE}
tidyjs::use_tidyjs()
```

Now that we've included tidyjs in this page, we can import a couple of functions that we're going to want to use. 
With tidyjs, all transformations are wrapped in a call `tidy()`, so we have to import `tidy`.
We also need `filter()` and `sliceMax()` for easy filtering.

```{js js_redirect = FALSE}
const { tidy, filter, sliceMax } = Tidy
```

The next step is to find the JSON data we just serialized and stashed in the browser.
We use `document.getElementById()` to find the element with the ID we chose previously.
Adding `.innerText` pulls out the inner text of that object.
Finally, we take the JSON text and parse it into a JavaScript object with `JSON.parse()`.

```{js js_redirect = FALSE}
wordsScored = JSON.parse(
  document.getElementById('words-scored').innerText
)
```

Here's a quick preview...

```{js}
tidy(
  wordsScored, // %>%
  sliceMax(5, 'score')
)
```

```{js js_redirect = FALSE}
function summarizeGuesses ({ guesses, results }) {
  const allComplete = [...guesses, ...results].every(s => s.length == 5)
  if (!allComplete) {
    console.error('All guesses and results must have 5 characters.')
    return
  }
  
  guesses = guesses.map(s => s.split(''))
  results = results.map(s => s.split(''))
  
  let exclude = Array(5).fill('')
  let exact = Array(5).fill('')
  let keep = []
  let discard = []
  
  for (i = 0; i < guesses.length; i++) {
    let g = guesses[i]
    let r = results[i]
    
    for (j = 0; j < r.length; j++) {
      if (r[j] == '+') {
        exact[j] = g[j]
        keep.push(g[j])
      } else if (r[j] == '-') {
        keep.push(g[j])
        exclude[j] += g[j]
      } else {
        discard.push(g[j])
      }
    }
  }
  
  const pattern = Array(5).fill('.')
  for (i = 0; i < 5; i++) {
    if (exact[i] != '') {
      pattern[i] = exact[i]
    } else if (exclude[i] != '') {
      pattern[i] = `[^${exclude[i]}]`
    }
  }
  
  discard = discard.filter(x => !keep.includes(x))
  return {discard, keep, pattern: pattern.join('')}
}
```

```{js js_redirect = FALSE}
function searchNextGuess ({ guesses, results }) {
  const guessResult = summarizeGuesses({guesses, results})
  
  return tidy(
    wordsScored,
    // discard words that contain a letter in the discard pile
    filter(d => !guessResult.discard.some(l => d.word.includes(l))),
    // keep only words that have all letters in the keep pile
    filter(d => guessResult.keep.every(l => d.word.includes(l))),
    // keep words that are consistent with results to date
    filter(d => RegExp(guessResult.pattern).test(d.word))
  )
}
```



```{js}
const rounds = {
  guesses: ["arose", "indol"],
  results: ["..-..", "+..+-"]
}

console.log(summarizeGuesses(rounds))

const answer = searchNextGuess(rounds)
console.table(answer[0])
```

```{js}
const rounds = {
  guesses: ["arose", "intro"],
  results: [".--..", "..+--"]
}

console.log(summarizeGuesses(rounds))

const answer = searchNextGuess(rounds)
answer.forEach(ans => console.log(`${ans.word} (${ans.score})`))
```

```{=html}
<script src="https://unpkg.com/gridjs/dist/gridjs.umd.js"></script>
<link href="https://unpkg.com/gridjs/dist/theme/mermaid.min.css" rel="stylesheet" />
<link href="wordle-component.css" rel="stylesheet">
<script src="wordle-component.js"></script>
```
