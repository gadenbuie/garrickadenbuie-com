---
title: Custom R Code Styles with styler
author: Garrick Aden-Buie
date: '2019-08-03'
slug: custom-styler-styles
categories:
  - Blog
tags:
  - R
  - Tips
  - Tricks
  - styler
description: post description
twitterImage: /path/to/image.png
rmd_source: ''
keywords: rstats
editor_options:
  chunk_output_type: console
---

<!-- Links -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, eval = FALSE, warning = FALSE, message = FALSE,
  fig.width = 9, fig.height = 10
)
options(htmltools.dir.version = TRUE)

# If using lightbox for plots, set `fig.show = FALSE`
# Usage: lightbox_img(knitr::fig_chunk("chunk-name", "png"))
lightbox_img <- function(url, alt = "", caption = "", preview = TRUE) {
  if (preview) {
    glue::glue(
      '<a href="{url}" data-featherlight="image">
      <div class="figure">
      <img src="{url}" alt="{alt}">
      <p class="caption">{caption}</p>
      </div>
      </a>
      '
    )
  } else {
    if (alt == "") alt <- "static image of the plot"
    glue::glue('<a href="{url}" data-featherlight="image">{alt}</a>')
  }
}
```

```{css echo=FALSE, eval=TRUE}
.container-flex {
  display: flex
}
.w-48 {
  width: 48%;
}
.mr-04 {
  margin-right: 4%;
}
```

[tidyverse-style]: https://style.tidyverse.org/
[styler-customizing]: http://styler.r-lib.org/articles/customizing_styler.html
[styler-quick-custom]: https://lorenzwalthert.netlify.com/post/customizing-styler-the-quick-way/
[google-r-style]: https://google.github.io/styleguide/Rguide.xml
[styler]: https://styler.r-lib.org

For all the precision that code brings to a data analysis,
there is still a huge range of possibilities as to how the code is written.
Whether you actively enfore a code style or not, 
you are likely to have developed a number of habits and patterns
when you write code.

How you lay out your code can seem tangential to the task at hand ---
the code runs, or doesn't it? ---
but it can have a large impact on how easy or difficult it is to maintain over time.
Among teams or collaborators,
writing in a consistent style makes it easier for others to approach and understand your code,
even if you're only consistent to yourself.

## My code style has evolved

Personally, I've always followed some internal guidelines
without ever completely formalizing my coding tics.
Early on when I was learning R,
I read through the [Google R style guide][google-r-style]
and then wrote code that "felt" similar.
My coding style has evolved significantly over the years 
through reading the code of others --- 
some of it good and some of it not so stylish ---
and also by reading dedicated style guides,
like the [tidyverse style guide][tidyverse-style].

There are certainly things that I do now 
that I thought were utterly bizzare when I first encountered them.
For example, the tidyverse styles used to recommend variable name and assignment on separate lines (left)
and discourage assignment on the same line (right).
I was very much *team same line* at the time.

<div class="container-flex">
<div class="w-48 mr-04">
```{r}
mtcars_4 <- 
  mtcars %>% 
  filter(cyl == 4) %>% 
  select(mpg, cyl, wt)
```
</div>
<div class="w-48">
```{r}
mtcars_4 <-  mtcars %>% 
  filter(cyl == 4) %>% 
  select(mpg, cyl, wt)
```
</div>
</div>

The tidyverse style guides 
[now recommend either approach](https://style.tidyverse.org/pipes.html#assignment-1),
but I've converted to be a huge fan of the seperate line between 
the variable name and the rest of the pipe for multi-line pipes.
Why?
Because it's easier to toggle "interactive mode" by commenting out the assignment line.
When I'm working on the code in the pipe and want to see the output,
I use <kbd>Command</kbd>/<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>
to comment out the first line,
and when I'm ready to move on I delete the comment to save the pipe output.
(I also decided I find it easier to read after living with it for a bit.)

![](tidyverse-style-assignment-demo.gif)

## Learning to live with a code style

I tell this ancedote because choosing a code style will always involve some friction.
A collaborator may not like a the code style you love or use.
You may not like the code style the group chooses.

But someone who has gone to the length of writing up guidelines for writing code
has probably also put some thought into their choices and recommendations.
And it may well be worth your time to give it shot and see how you feel.

On the other hand, if you'd rather just write your code and let someone else deal with styling it,
there's a package for that!
The [[styler]]{.pkg} package, by 
[Lorenz Walthert](http://lorenzwalthert.netlify.com/) and
[Kirill MÃ¼ller](http://krlmlr.info/),
provides a few functions for automatically styling R code.
It ships with a set of rules that enforce (or nearly enforce)
the tidyverse style guide,
and you can easily style your current selection, file, or package code with
[RStudio addins](http://styler.r-lib.org/reference/styler_addins.html).

## My personal code style

As you probably know by now, 
I really like the tidyverse style guide.
But I also have _opinions_.
I have one medium-sized quibble with 
the tidyverse style guide recommendations for function definitions.
I also prefer more strictly consistent usage of line breaks in function calls.
Overall, my quibbles boil down to wanting strictly consistent line breaks and indents.

### Function definitions

I really like being able to scan the code and quickly understand the structure and flow of the program.
It's common practice among R programmers to 
start specifying the arguments to a function on one line and
then to continue the arguments on the next line, 
but with the arguments indented in line with the end of the function name.

For example, the tidyverse style guide [recommends the following style for long function names or definitions](https://style.tidyverse.org/functions.html#long-lines-1).

&#x1F61D;

```{r}
long_function_name <- function(a = "a long argument",
                               b = "another argument",
                               c = "another long argument") {
  # As usual code is indented by two spaces.
}
```

I don't like when how the code is crammed to the right of the screen,
or how the indentation of the arguments is a function of how many characters are in the function name
rather than their position within the code's syntax tree.

In terms of reading flow, when scanning a script containing this style of code,
I need to jump to the right to see what kind of arguments `long_function_name()` takes.
It's also common for me to tinker with the ordering of inputs while working out the API for a function, 
and it's much easier to reorder arguments by pressing
<kbd>Alt</kbd> + <kbd>&#x02191;</kbd> / <kbd>&#x02193;</kbd> 
in RStudio to move single lines up or down.

&#x1F917;

```{r}
long_function_name <- function(
  a = "a long argument",
  b = "another argument",
  c = "another long argument"
) {
  # As usual code is indented by two spaces.
}
```

### Line breaks inside function calls

Similarly, for function calls that don't fit on a single line,
each argument should have it's own line.
This is how it's described in tidyverse style (and I fully agree)

> If the arguments to a function don't all fit on one line, put each argument on its own line and indent.
>
> <cite><https://style.tidyverse.org/pipes.html#long-lines-2></cite>

```{r}
iris %>%
  group_by(Species) %>%
  summarise(
    Sepal.Length = mean(Sepal.Length),
    Sepal.Width = mean(Sepal.Width),
    Species = n_distinct(Species)
  )
```

But [styler]{.pkg}'s `styler::tidyverse_style()` will allow multiple arguments to exist on the same line.

```{r}
iris %>%
  group_by(Species) %>%
  summarise(
    Sepal.Length = mean(Sepal.Length),
    Sepal.Width = mean(Sepal.Width), Species = n_distinct(Species)
  )
```

In my preferred syle, if there are **any** line breaks inside a function call, then all arguments should get line breaks.

## Creating custom style rules for styler

Start from `styler:tidyverse_style()`

```{r eval=TRUE}
tidy_style <- styler::tidyverse_style()
```

pick style "area" where your new rule will fit in, 
or where the rule that you want to overwrite exists

```{r eval=TRUE}
names(tidy_style)
```

for example, the rule about indention of function arguments lives in `indention`.

```{r eval=TRUE}
names(tidy_style$indention)

tidy_style$indention$update_indention_ref_fun_dec
```

My initial reaction: huh?
But I can gather that this function applies a style rule when it
gets an expression that starts with the `FUNCTION` token.
So I inserted a browser statement just inside the if statement

```{r eval=TRUE}
tidy_style$indention$update_indention_ref_fun_dec <- function (pd_nested) {
  if (pd_nested$token[1] == "FUNCTION") {
    # I would call browser() here...
    # but for the blog I'll grab pd_nested so we can see it
    assign("pd_nested_in", pd_nested, .GlobalEnv)
    seq <- rlang::seq2(3, nrow(pd_nested) - 2)
    pd_nested$indention_ref_pos_id[seq] <- pd_nested$pos_id[2]
    assign("pd_nested_out", pd_nested, .GlobalEnv)
    stop("break for blog")
  }
  pd_nested
}
```

```{r error=TRUE, eval=TRUE}
styler::style_text(
  text = '
  long_function_name <- function(a = "a long argument",
                               b = "another argument") {
    # function code...
  }',
  transformers = tidy_style
)

pd_cols <- c("pos_id", "token", "text", "indent", "indention_ref_pos_id")

pd_nested_in[,  pd_cols]
pd_nested_out[, pd_cols]
```


By comparing `pd_nested_in` and `pd_nested_out` 
(and by looking at the source code, obvs), 
I worked out that `indention_ref_pos_id` and `indent` were
the two variables I needed to tweak.
Ultimately, I figured out that `indention_ref_pos_id` is,
in essence,
*indent relative to the item with `pos_id == indention_ref_pos_id`*
and `indent` is the amount of indenting.

What I realized I wanted here was to simply indent newlines inside the `function()` call
by the usual 2 spaces that I use for indenting
and let the rule about arguments in functions take care of line breaks.

Here's the `update_indention_ref_fun_dec()` rule that I settled on.

```{r eval=TRUE}
tidy_style$indention$update_indention_ref_fun_dec <- function(pd_nested) {
  if (pd_nested$token[1] == "FUNCTION") {
    seq <- rlang::seq2(3, nrow(pd_nested) - 2)
    pd_nested$indention_ref_pos_id[seq] <- 0
    pd_nested$indent[seq] <- 2
    assign("pd_nested_mine", pd_nested, .GlobalEnv)
  }
  pd_nested
}

styler::style_text(
  text = '
  long_function_name <- function(a = "a long argument",
                               b = "another argument") {
    # function code...
  }',
  transformers = tidy_style
)

pd_nested_mine[, pd_cols]
```


### Line Breaks

```{r}
tidy_style$line_break$set_linebreak_each_argument_if_multi_line <- function(pd) {
    if (!(any(pd$token == "','"))) {
      return(pd)
    }
    # does this expression contain expressions with linebreaks?
    has_children <- purrr::some(pd$child, purrr::negate(is.null))
    has_internal_linebreak <- FALSE
    is_function_definition <- pd$token[1] == "FUNCTION"
    if (has_children && !is_function_definition) {
      children <- pd$child

      # don't count anything inside {} as internal linebreaks
      idx_pre_open_brace <- which(pd$token_after == "'{'")
      if (length(idx_pre_open_brace)) {
        children[idx_pre_open_brace + 1] <- NULL
      }

      has_internal_linebreak <- children %>%
        purrr::discard(is.null) %>%
        purrr::map_int(~ sum(.$newlines, .$lag_newlines)) %>%
        any(. > 0)
    }

    has_no_linebreaks <- sum(pd$newlines, pd$lag_newlines) < 1
    if (!has_internal_linebreak && has_no_linebreaks) {
      return(pd)
    }

    idx_comma <- which(pd$token == "','")
    idx_open_paren <- grep("'[[(]'", pd$token)
    idx_close_paren <- grep("'(]|\\))'", pd$token)
    pd[idx_comma + 1L, "lag_newlines"] <- 1L
    if (length(idx_open_paren)) {
      # Add linebreak after open parens
      # ...I don't know why but this has to be `lag_newlines`
      pd[idx_open_paren[1] + 1L, "lag_newlines"] <- 1L
    }
    if (length(idx_close_paren)) {
      # Add linebreak before close parens
      pd[idx_close_paren[length(idx_close_paren)], "lag_newlines"] <- 1L
    }
    pd
  }
```

